import * as babel from '@babel/types';
import { defaultSplitRE } from '@unocss/core';
import { transform, NodeTypes } from '@vue/compiler-core';
import { parse } from '@vue/compiler-sfc';
import { parseModule } from 'magicast';
import { parsePath } from 'ufo';

function generateSelectors(prefix, values) {
  prefix = prefix.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
  return values.filter((v) => Boolean(v) && v !== ":").map((v) => `[${prefix}~="${v}"]`);
}
function normalizePrefixes(prefixes) {
  const camelCasePrefixes = prefixes.map((prefix) => prefix.replace(/-([a-z])/g, (_, c) => c.toUpperCase()));
  return [.../* @__PURE__ */ new Set([...prefixes, ...camelCasePrefixes])];
}
function getLiteralValue(node) {
  if (node.type === "ConditionalExpression") {
    return [node.consequent, node.alternate].map(getLiteralValue);
  }
  if (node.type === "StringLiteral") {
    return node.value;
  }
  if (node.type === "TemplateLiteral") {
    if (node.expressions.length > 0) {
      return void 0;
    }
    return node.quasis.map((q) => q.value.cooked).join("");
  }
  if (node.type === "ObjectExpression") {
    return getObjectLiteralValue(node);
  }
  return void 0;
}
function getObjectLiteralValue(node) {
  return Object.fromEntries(
    node.properties.filter((prop) => prop.type === "ObjectProperty").flatMap((prop) => {
      const key = prop.key.type === "Identifier" ? prop.key.name : prop.key.type === "StringLiteral" ? prop.key.value : null;
      if (!key) {
        return [];
      }
      return [[key, getLiteralValue(prop.value)]];
    })
  );
}
function discoverVariants(node, prefixes) {
  const result = [];
  babel.traverse(node, {
    enter(node2) {
      if (node2.type === "ObjectExpression") {
        const object = getObjectLiteralValue(node2);
        for (let [key, value] of Object.entries(object)) {
          if (prefixes.includes(key) && value) {
            if (!Array.isArray(value)) {
              value = [value];
            }
            for (let v of value) {
              if (typeof v === "object" && v !== null && "default" in v) {
                v = v.default;
              }
              if (typeof v !== "string") {
                continue;
              }
              result.push([key, v]);
            }
          }
        }
      }
      if (node2.type === "AssignmentPattern") {
        const { left, right } = node2;
        if (left.type === "Identifier" && right.type === "StringLiteral") {
          const prefix = left.name;
          const value = right.value;
          if (prefixes.includes(prefix)) {
            result.push([prefix, value]);
          }
        }
      }
    }
  });
  return result.flatMap(([key, v]) => {
    const values = v.split(defaultSplitRE);
    return generateSelectors(key, values);
  });
}
function parseCodeAst(code, id) {
  try {
    const { $ast: node } = parseModule(code, {
      sourceFileName: id
    });
    return node;
  } catch (e) {
    throw new SyntaxError(`Failed to parse code ast${id ? ` (file: ${id})` : ""}`, { cause: e });
  }
}
function extractTemplateExpressions(node) {
  const expressions = [];
  transform(node, {
    nodeTransforms: [
      // readonly "transformer", doesn't do any changes
      (node2) => {
        if (node2.type === NodeTypes.ELEMENT) {
          node2.props.forEach((prop) => {
            if (prop.type === NodeTypes.DIRECTIVE && prop.exp?.ast) {
              expressions.push(prop.exp.ast);
            }
          });
        }
      }
    ]
  });
  return expressions;
}
const SUPPORTED_EXTENSION_IDS = /\.(?:[mc]?[jt]sx?|vue)$/;
function extractorVueScript(options) {
  return {
    name: "@una-ui/extractor-vue-script",
    order: 0,
    async extract({ code, id }) {
      const cleanPath = parsePath(id).pathname;
      if (!SUPPORTED_EXTENSION_IDS.test(cleanPath)) {
        return void 0;
      }
      const astExprs = [];
      if (cleanPath.endsWith(".vue")) {
        const sfc = parse(code, {
          filename: cleanPath
        });
        if (sfc.descriptor.script) {
          astExprs.push(parseCodeAst(sfc.descriptor.script.content));
        }
        if (sfc.descriptor.scriptSetup) {
          astExprs.push(parseCodeAst(sfc.descriptor.scriptSetup.content));
        }
        if (sfc.descriptor.template?.ast) {
          astExprs.push(...extractTemplateExpressions(sfc.descriptor.template.ast));
        }
      } else {
        astExprs.push(parseCodeAst(code, id));
      }
      const prefixes = normalizePrefixes(options?.prefixes ?? []);
      return [...new Set(
        astExprs.flatMap((node) => discoverVariants(node, prefixes))
      )];
    }
  };
}

export { extractorVueScript as default };
