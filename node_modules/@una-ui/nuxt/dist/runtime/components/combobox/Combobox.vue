<script>
import { reactiveOmit } from "@vueuse/core";
import { defu } from "defu";
import { ComboboxRoot, useForwardPropsEmits } from "reka-ui";
import { cn } from "../../utils";
</script>

<script setup>
import { computed } from "vue";
import ComboboxAnchor from "./ComboboxAnchor.vue";
import ComboboxEmpty from "./ComboboxEmpty.vue";
import ComboboxGroup from "./ComboboxGroup.vue";
import ComboboxInput from "./ComboboxInput.vue";
import ComboboxItem from "./ComboboxItem.vue";
import ComboboxItemIndicator from "./ComboboxItemIndicator.vue";
import ComboboxList from "./ComboboxList.vue";
import ComboboxSeparator from "./ComboboxSeparator.vue";
import ComboboxTrigger from "./ComboboxTrigger.vue";
import ComboboxViewport from "./ComboboxViewport.vue";
const props = defineProps({
  modelValue: { type: null, required: false },
  items: { type: Array, required: false },
  labelKey: { type: null, required: false },
  valueKey: { type: null, required: false },
  groupSeparator: { type: Boolean, required: false },
  textEmpty: { type: String, required: false, default: "No items found." },
  label: { type: String, required: false },
  multiple: { type: null, required: false },
  _comboboxAnchor: { type: Object, required: false },
  _comboboxEmpty: { type: Object, required: false },
  _comboboxGroup: { type: Object, required: false },
  _comboboxInput: { type: Object, required: false },
  _comboboxItem: { type: Object, required: false },
  _comboboxItemIndicator: { type: Object, required: false },
  _comboboxLabel: { type: Object, required: false },
  _comboboxList: { type: Object, required: false },
  _comboboxSeparator: { type: Object, required: false },
  _comboboxTrigger: { type: Object, required: false },
  _comboboxViewport: { type: Object, required: false },
  _comboboxCheckbox: { type: Object, required: false },
  _comboboxContent: { type: Object, required: false },
  _comboboxPortal: { type: Object, required: false },
  una: { type: Object, required: false },
  open: { type: Boolean, required: false },
  defaultOpen: { type: Boolean, required: false },
  resetSearchTermOnBlur: { type: Boolean, required: false },
  resetSearchTermOnSelect: { type: Boolean, required: false },
  openOnFocus: { type: Boolean, required: false },
  openOnClick: { type: Boolean, required: false },
  ignoreFilter: { type: Boolean, required: false },
  resetModelValueOnClear: { type: Boolean, required: false },
  defaultValue: { type: null, required: false },
  dir: { type: String, required: false },
  disabled: { type: Boolean, required: false },
  highlightOnHover: { type: Boolean, required: false },
  by: { type: [String, Function], required: false },
  asChild: { type: Boolean, required: false },
  as: { type: null, required: false },
  name: { type: String, required: false },
  required: { type: Boolean, required: false },
  status: { type: String, required: false },
  id: { type: String, required: false },
  class: { type: null, required: false },
  size: { type: null, required: false, default: "sm" }
});
const emits = defineEmits(["update:modelValue", "highlight", "update:open"]);
const rootProps = reactiveOmit(props, [
  "items",
  "una",
  "size",
  "label",
  "labelKey",
  "valueKey",
  "groupSeparator",
  "textEmpty",
  "_comboboxAnchor",
  "_comboboxEmpty",
  "_comboboxGroup",
  "_comboboxInput",
  "_comboboxItem",
  "_comboboxItemIndicator",
  "_comboboxLabel",
  "_comboboxList",
  "_comboboxSeparator",
  "_comboboxTrigger",
  "_comboboxViewport",
  "_comboboxCheckbox"
]);
const forwarded = useForwardPropsEmits(rootProps, emits);
const labelKey = computed(() => props.labelKey?.toString() ?? "label");
const valueKey = computed(() => props.valueKey?.toString() ?? "value");
const hasGroups = computed(() => {
  return Array.isArray(props.items) && props.items.length > 0 && typeof props.items[0] === "object" && "items" in props.items[0];
});
function getItemProperty(item, key) {
  if (item == null)
    return "";
  return typeof item !== "object" ? item : item[key];
}
function findItemByValue(value) {
  if (!props.items)
    return void 0;
  if (hasGroups.value) {
    for (const group of props.items) {
      const found = group.items?.find((item) => getItemProperty(item, valueKey.value) === value);
      if (found)
        return found;
    }
    return void 0;
  } else {
    return props.items.find((item) => getItemProperty(item, valueKey.value) === value);
  }
}
function getDisplayValue(val) {
  if (!val || Array.isArray(val) && val.length === 0)
    return "";
  if (props.multiple && Array.isArray(val)) {
    return val.map((v) => {
      if (typeof v !== "object" || v === null) {
        const item = findItemByValue(v);
        return item ? getItemProperty(item, labelKey.value) : v;
      }
      return getItemProperty(v, labelKey.value) || getItemProperty(v, valueKey.value) || "";
    }).filter(Boolean).join(", ");
  }
  if (typeof val !== "object" || val === null) {
    const item = findItemByValue(val);
    return item ? getItemProperty(item, labelKey.value) : String(val || "");
  }
  return getItemProperty(val, labelKey.value) || getItemProperty(val, valueKey.value) || "";
}
function isItemSelected(item) {
  if (item == null)
    return false;
  const itemValue = getItemProperty(item, valueKey.value);
  if (props.multiple && Array.isArray(props.modelValue)) {
    return props.modelValue.includes(itemValue);
  }
  return typeof props.modelValue === "object" && props.modelValue !== null ? getItemProperty(props.modelValue, valueKey.value) === itemValue : props.modelValue === itemValue;
}
</script>

<template>
  <ComboboxRoot
    data-slot="combobox"
    :class="cn(
  'combobox',
  props.una?.combobox,
  props.class
)"
    v-bind="forwarded"
  >
    <slot>
      <ComboboxAnchor
        v-bind="props._comboboxAnchor"
        :una
      >
        <slot name="anchor">
          <template
            v-if="$slots.trigger || $slots.triggerRoot"
          >
            <slot name="trigger-wrapper">
              <ComboboxTrigger
                v-bind="props._comboboxTrigger"
                :id
                :status
                :class="cn(
  props._comboboxTrigger?.class
)"
                :size
              >
                <slot name="trigger" :model-value :open />
              </ComboboxTrigger>
            </slot>
          </template>

          <template v-else>
            <slot name="input-wrapper" :model-value :open>
              <ComboboxInput
                :id
                :display-value="(val) => getDisplayValue(val)"
                name="frameworks"
                :status
                :class="cn(
  'text-1em',
  props._comboboxInput?.class
)"
                :una="defu(props._comboboxInput?.una, {
  inputLeading: 'text-1.1428571428571428em',
  inputTrailing: 'text-1.1428571428571428em',
  inputStatusIconBase: 'text-1.1428571428571428em'
})"
                :size
                v-bind="props._comboboxInput"
              />
            </slot>
          </template>
        </slot>
      </ComboboxAnchor>

      <ComboboxList
        v-bind="{ ...props._comboboxList, ...props._comboboxContent }"
        :_combobox-portal
        :size
        :una
      >
        <slot name="list">
          <slot name="input-wrapper" :model-value :open>
            <ComboboxInput
              v-if="$slots.trigger || $slots.triggerRoot"
              input="~"
              :class="cn(
  'border-b-1 rounded-none text-1em',
  props._comboboxInput?.class
)"
              leading="combobox-input-leading-icon"
              :una="defu(props._comboboxInput?.una, {
  inputLeading: 'text-1.1428571428571428em',
  inputTrailing: 'text-1.1428571428571428em',
  inputStatusIconBase: 'text-1.1428571428571428em'
})"
              :size
              v-bind="props._comboboxInput"
            />
          </slot>

          <slot name="header" />

          <slot name="body">
            <ComboboxViewport
              v-bind="props._comboboxViewport"
              :una
            >
              <ComboboxEmpty
                v-bind="props._comboboxEmpty"
                :class="cn(
  props._comboboxEmpty?.class
)"
                :size
                :una
              >
                <slot name="empty">
                  {{ props.textEmpty }}
                </slot>
              </ComboboxEmpty>

              <!-- Non-grouped items -->
              <template v-if="!hasGroups">
                <ComboboxGroup
                  v-bind="props._comboboxGroup"
                  :label="props.label"
                  :una
                >
                  <slot name="group">
                    <ComboboxItem
                      v-for="item in items"
                      :key="getItemProperty(item, valueKey)"
                      :value="props.multiple ? getItemProperty(item, valueKey) : item"
                      :size
                      v-bind="props._comboboxItem"
                      :class="cn(
  props._comboboxItem?.class
)"
                      :una
                    >
                      <slot name="item" :item="item" :selected="isItemSelected(item)">
                        <slot name="label" :item="item">
                          {{ getItemProperty(item, labelKey) }}
                        </slot>

                        <ComboboxItemIndicator
                          v-bind="props._comboboxItemIndicator"
                          :una
                        >
                          <slot name="item-indicator" :item="item">
                            <NIcon name="i-lucide-check" />
                          </slot>
                        </ComboboxItemIndicator>
                      </slot>
                    </ComboboxItem>
                  </slot>
                </ComboboxGroup>
              </template>

              <!-- Grouped items -->
              <template v-else>
                <ComboboxGroup
                  v-for="(group, i) in items"
                  :key="i"
                  v-bind="props._comboboxGroup"
                  :label="group.label"
                  :una
                >
                  <ComboboxSeparator
                    v-if="i > 0 && props.groupSeparator"
                    v-bind="props._comboboxSeparator"
                    :una
                  />

                  <slot name="group" :group="group">
                    <ComboboxItem
                      v-for="item in group.items"
                      :key="getItemProperty(item, valueKey)"
                      :value="props.multiple ? getItemProperty(item, valueKey) : item"
                      :size
                      v-bind="{ ...props._comboboxItem, ...group._comboboxItem }"
                      :class="cn(
  props._comboboxItem?.class
)"
                      :una
                    >
                      <slot name="item" :item="item" :group="group" :selected="isItemSelected(item)">
                        <slot name="label" :item="item">
                          {{ getItemProperty(item, labelKey) }}
                        </slot>

                        <ComboboxItemIndicator
                          v-bind="props._comboboxItemIndicator"
                          :una
                        >
                          <slot name="indicator" :item="item" />
                        </ComboboxItemIndicator>
                      </slot>
                    </ComboboxItem>
                  </slot>
                </ComboboxGroup>
              </template>
            </ComboboxViewport>
          </slot>

          <slot name="footer" />
        </slot>
      </ComboboxList>
    </slot>
  </ComboboxRoot>
</template>
